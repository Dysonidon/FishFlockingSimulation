/**
 * SeaCreature.java
 * <p>
 * Copyright (c) 2025 Jacob Broomfield.
 * All rights reserved.
 */
package Main;

import UI.CreatureUiController;
import javafx.animation.KeyFrame;
import javafx.animation.Timeline;
import javafx.scene.layout.Pane;
import javafx.util.Duration;
import java.util.ArrayList;
import java.util.List;

/**
 * This is a sea creature class, a blueprint for all sea creature objects.
 *
 * @author Jacob Broomfield
 * @version 1.0
 */
public abstract class SeaCreature {
    protected double MAX_FORCE = 0.15;
    protected double BORDER_OFFSET;
    protected double MAX_SPEED;
    protected Vector position;
    protected Vector velocity;
    protected Vector acceleration;
    private double wanderTheta;
    protected Pane boardReference;
    protected CreatureUiController entityView;
    private final Timeline movement;
    private Applications app;
    protected PhysicsHandler physicsHandler;

    /**
     * Constructor for a sea creature object.
     *
     * @param boardReference board reference.
     */
    public SeaCreature(Pane boardReference) {
        this.boardReference = boardReference;
        this.wanderTheta = Math.PI/2;
        this.velocity = new Vector(0, 0);//empty initial velocity
        this.acceleration = new Vector(0, 0);//empty initial acceleration
        this.movement = new Timeline(new KeyFrame(Duration.millis(16), _ -> app.moveEntities(this)));
        this.movement.setCycleCount(Timeline.INDEFINITE);
        this.physicsHandler = new PhysicsHandler();
    }

    /**
     * Creates an instance of itself based off of its type.
     *
     * @param type creature type.
     * @param x position.
     * @param y position.
     * @param boardReference board reference.
     * @param fishes fish reference.
     * @param sharks shark reference.
     * @return fish or shark object.
     */
    public static SeaCreature create(String type, double x, double y, Pane boardReference, List<Fish> fishes, List<Shark> sharks) {
        return switch (type) {
            case "fish" -> new Fish(x, y, boardReference, (ArrayList<Fish>) fishes, sharks);
            case "shark" -> new Shark(x, y, boardReference, fishes);
            default -> throw new IllegalStateException("Unexpected value: " + type);
        };
    }

    /**
     * Starts the entity movement timeline.
     */
    public void startMoving() {
        movement.play();
    }

    /**
     * Stops the entity movement timeline.
     */
    public void stopMoving() {
        movement.stop();
    }

    /**
     * Random wander movements generated by a wander point around a wander radius.
     */
    public void wander() {
        Vector targetVelocity = velocity.copy();//a target point set 100 pixels ahead
        targetVelocity.setMagnitude(100);
        targetVelocity.add(getPosition());

        double wanderRadius = 50;//radius around wander point
        double theta = wanderTheta + velocity.getHeading();
        double x = wanderRadius * Math.cos(theta);
        double y = wanderRadius * Math.sin(theta);
        targetVelocity.add(new Vector(x,y));

        Vector steerForce = targetVelocity.subtract(getPosition());//steer position to wander point
        steerForce.setMagnitude(MAX_FORCE);
        physicsHandler.applyForce(this, steerForce);
        double RANGE_DISPLACEMENT = 0.3;
        //randomly displace wander theta to change wander direction.
        wanderTheta += -RANGE_DISPLACEMENT + (RANGE_DISPLACEMENT + RANGE_DISPLACEMENT) * Math.random();
    }

    /**
     * Calculates a steer fore based off of the closeness of the board edges.
     *
     * @return boundary steer force.
     */
    public Vector checkBoundaries() {
        Vector steerForce = new Vector(0, 0);//no steering force at first
        double strength;
        if (getPosition().x < BORDER_OFFSET) {//push right when at left border offset
            //gradually increased strength as it gets closer meaning less to minus from final strength
            strength = 1.0 - (getPosition().x / BORDER_OFFSET);
            //add strength to rightward steer force scaled by the max force allowed
            steerForce.x += strength * MAX_FORCE;
        } else if (getPosition().x > boardReference.getWidth() - BORDER_OFFSET) {//push left when at right border offset
            strength = 1.0 - ((boardReference.getWidth() - getPosition().x) / BORDER_OFFSET);
            steerForce.x -= strength * MAX_FORCE;
        }
        if (getPosition().y < BORDER_OFFSET) {//push down when at upper border offset
            strength = 1.0 - (getPosition().y / BORDER_OFFSET);
            steerForce.y += strength * MAX_FORCE;
        } else if (getPosition().y > boardReference.getHeight() - BORDER_OFFSET) {//push up when at lower border offset
            strength = 1.0 - ((boardReference.getHeight() - getPosition().y) / BORDER_OFFSET);
            steerForce.y -= strength * MAX_FORCE;
        }

        if (steerForce.getMagnitude() == 0) {
            return null; // not near any wall
        }
        steerForce.limitMagnitude(MAX_FORCE);
        return steerForce;
    }

    /**
     * Calculates the steer force for separating from other entities.
     *
     * @param Entities others.
     * @return steer force.
     */
    public Vector calculateSeparationForce(List<? extends SeaCreature> Entities) {
        double desiredSeparation;
        if (this instanceof Shark) {
            desiredSeparation = 50;
        } else {
            desiredSeparation = 30;
        }
        Vector steerForce = new Vector(0, 0);
        int count = 0;

        for (SeaCreature otherEntity : Entities) {
            if (otherEntity != this) {
                double distance = getDifference(this.getPosition(), otherEntity.getPosition()).getMagnitude();
                if (distance > 0 && distance < desiredSeparation) {//vector pointing away from neighbour
                    Vector diff = getDifference(this.getPosition(), otherEntity.getPosition());
                    diff.normalize();
                    diff.divide(distance);//weight by distance

                    if (this instanceof Fish thisFish && otherEntity instanceof Fish otherFish) {//different
                        if (thisFish.entityView.getColour() != otherFish.entityView.getColour()) {
                            diff.multiply(2.0);
                        }
                    }

                    steerForce.add(diff);
                    count++;
                }
            }
        }

        if (count > 0) {
            steerForce.divide(count);//average
        }
        if (steerForce.getMagnitude() > 0) {
            steerForce.setMagnitude(MAX_SPEED);
            steerForce.subtract(this.velocity);
            steerForce.limitMagnitude(MAX_FORCE);
        }
        return steerForce;
    }

    /**
     * returns the steering force pointing towards the target vector.
     *
     * @param target vector position.
     * @return steer force.
     */
    public Vector seek(Vector target) {
        //calculate desired velocity
        Vector desiredSteerForce = target.copy().subtract(getPosition());
        desiredSteerForce.setMagnitude(MAX_SPEED);
        //steering force is desired velocity minus velocity
        desiredSteerForce.subtract(velocity);
        desiredSteerForce.limitMagnitude(MAX_FORCE);
        return desiredSteerForce;
    }

    /**
     * Shows the position and heading of the entity based of what the position and velocity have been changed to.
     */
    public void showEntityViewUpdate() {
        entityView.setPosition(getPosition().x, getPosition().y);
        entityView.setRotation(Math.toDegrees(velocity.getHeading()));
    }

    /**
     * gets difference between 2 given vectors (returns vector with a magnitude of that difference).
     *
     * @param startPosition starting vector.
     * @param targetPosition ending vector.
     * @return new magnitude of difference.
     */
    protected Vector getDifference(Vector startPosition, Vector targetPosition) {
        return startPosition.copy().subtract(targetPosition);
    }

    /**
     * Returns the entity position.
     *
     * @return entity position.
     */
    public Vector getPosition() {
        return position;
    }

    /**
     * Returns the entity velocity.
     *
     * @return entity velocity.
     */
    public Vector getVelocity() {
        return velocity;
    }

    /**
     * Returns the entity acceleration.
     *
     * @return entity acceleration.
     */
    public Vector getAcceleration() {
        return acceleration;
    }

    /**
     * Returns the entity view.
     *
     * @return entity view.
     */
    public CreatureUiController getEntityView() {
        return entityView;
    }

    /**
     * Sets the application.
     *
     * @param app application.
     */
    public void setApp(Applications app) {
        this.app = app;
    }


    public void setEntityView(CreatureUiController entityView) {
        this.entityView = entityView;
        this.entityView.setPosition(getPosition().x, getPosition().y);
    }
}
